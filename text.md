Hello, I’m Harsh Yadav and I chose the theme of Entertainment, Games & Engagement Platforms, which focuses on building engaging experiences that keep users interacting. My project fulfills all the requirements of the theme including complex game mechanics, advanced score systems, real-time UI updates, event-driven programming, and complex UI state handling. So, I’ve built an advanced version of the 2048 puzzle game, and it is built entirely with HTML, CSS, and Vanilla JavaScript with no frameworks like React used, to demonstrate my raw understanding of the language.

When you open the game, you will see a clean, responsive 4x4 grid and a custom UI panel that tracks not just the score, but also your high score, total moves, and a special combo counter. The entire interface is dynamic; when the game initializes, I have this function called createBoard() that sets up the grid. Instead of hardcoding the HTML, I am dynamically generating the 16 tile divs using JavaScript loops and pushing them into a squares array. This array acts as the single source of truth for the game state, separating my data logic from the visual presentation, which is a key concept in game development.

The core logic of the game relies on a function I wrote called slideAndMerge(). This is where the magic happens. When you press an arrow key, the code takes the row or column, filters out the zeros to slide the numbers together, and then checks adjacent numbers. If they match, they combine into a single value. But here is where I made it unique for the "Engagement" theme: I implemented a combo system. If you merge tiles consecutively, a combo variable increments, and I use a multiplier logic so that your score isn't just the sum of the tiles, but is boosted by your combo streak. This encourages players to think ahead and keeps them interacting longer.

Talking about the visuals, I didn't just want static numbers, so I created a particle system entirely in JavaScript. When tiles merge, the createParticles() function triggers. I’m literally using trigonometry—specifically Math.cos and Math.sin—to calculate the trajectory of little div elements that explode outward from the merge point. These particles are created dynamically, animated with CSS transitions, and then removed from the DOM using setTimeout after 600 milliseconds to prevent memory leaks. This provides that "juicy" game feel that makes modern web games satisfying to play.

Now, one of the most technical parts of this project is the state management for the "Undo" feature. I created a gameState object that tracks the previousBoard, the total merges, and the start time. Every time the player makes a move, I first call a saveState() function that takes a snapshot of the current grid using the .map() method. If the user makes a mistake and clicks the Undo button, I can revert the entire board to that saved array. This is exactly the kind of complex state handling that frameworks usually manage, but doing it manually really helped me understand how history stacks and memory management work in a browser environment.

For the input handling, the game is fully event-driven. I have a control() function that listens for keydown events. It detects which arrow key or WASD key was pressed and triggers the corresponding movement function, like moveRight() or moveUp(). But before moving, it checks if the move is valid to avoid unnecessary processing. I also separated the view logic into an addColours() function, which runs independently to update the CSS classes of the tiles based on their numerical value, ensuring the colors shift instantly as the numbers grow from 2 to 4 to 8 and beyond.

The game also features a win and loss detection system that runs after every move. The checkForGameOver() function scans the grid not just for empty spots, but it also intelligently checks if any adjacent tiles match. If no moves are possible, it triggers a "Game Over" overlay. Conversely, if you reach the 2048 tile, it triggers a createFireworks() function, which is another loop that generates visual effects to celebrate the win.

Throughout this entire project, I had to think about how to manipulate the DOM efficiently without causing lag, how to handle asynchronous animations using setTimeout, and how to structure my code into small, modular functions like generate, slide, and updateDisplay. The HTML handles the structure, the CSS variables allow for easy theming, and the JavaScript handles all the complex logic, creating a seamless and engaging experience for the user.